{"value": "512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/imurmurhash\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n      \"integrity\": \"sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==\",\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=0.8.19\"\n      }\n    },\n    \"node_modules/indent-string\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz\",\n      \"integrity\": \"sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==\",\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/infer-owner\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/infer-owner/-/infer-owner-1.0.4.tgz\",\n      \"integrity\": \"sha512-IClj+Xz94+d7irH5qRyfJonOdfTzuDaifE6ZPWfx0N0+/ATZCbuTPq2prFl526urkQd90WyUKIh1DfBQ2hMz9A==\",\n      \"license\": \"ISC\",\n      \"optional\": true\n    },\n    \"node_modules/inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n      \"deprecated\": \"This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.\",\n      \"license\": \"ISC\",\n      \"optional\": true,\n      \"dependencies\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMC\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n\n\n    const salt = data.subarray(0, SALT_LENGTH);\n    const iv = data.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const tag = data.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    const encrypted = data.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);\n    \n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u0438\u0437 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044f\n    const key = deriveKey(masterPassword, salt);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c decipher\n    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n    decipher.setAuthTag(tag);\n    \n    // \u0414\u0435\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  } catch (error: any) {\n    logger.error('\u041e\u0448\u0438\u0431\u043a\u0430 \u0434\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f:', error);\n    throw new Error('\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0442\u0435\u0440-\u043f\u0430\u0440\u043e\u043b\u044c \u0438\u043b\u0438 \u043f\u043e\u0432\u0440\u0435\u0436\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435');\n  }\n}\n\n/**\n * \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c\n */\nexport function generatePassword(options: {\n  length?: number;\n  includeUppercase?: boolean;\n  includeLowercase?: boolean;\n  includeNumbers?: boolean;\n  includeSymbols?: boolean;\n} = {}): string {\n  const {\n    length = 16,\n    includeUppercase = true,\n    includeLowercase = true,\n    includeNumbers = true,\n    includeSymbols = true\n  } = options;\n\n  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '0123456789';\n  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n  let charset = '';\n  if (includeUppercase) charset += uppercase;\n  if (includeLowercase) charset += lowercase;\n  if (includeNumbers) charset += numbers;\n  if (includeSymbols) charset += symbols;\n\n  if (charset.length === 0) {\n    throw new Error('\u0425\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u0442\u0438\u043f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d');\n  }\n\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    const randomIndex = crypto.randomInt(0, charset.length);\n    password += charset[randomIndex];\n  }\n\n  return password;\n}\n\n", "timestamp": 1767035858.995119, "ttl": 3600}